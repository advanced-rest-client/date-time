<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../node_modules/sinon/pkg/sinon.js"></script>

  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="LongWeekday">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" weekday="long"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="LongMonth">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" month="long"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="NumericYear">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" year="numeric"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="NumericDay">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" day="numeric"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="NumericHour">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" hour="numeric"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="NumericMinute">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" minute="numeric"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="NumericSecond">
      <template>
        <date-time locales="en-US" time-zone="UTC" date="2010-12-10T11:05:45.000Z" second="numeric"></date-time>
      </template>
    </test-fixture>

    <test-fixture id="Empty">
      <template>
        <date-time></date-time>
      </template>
    </test-fixture>

    <script type="module">
    import '../date-time.js';
    // import { a11ySuite } from '../../../wct-browser-legacy/a11ySuite.js';
    const EDGE_IS_STILL_SO_BAD = /\u200E/g;
    function normalizeString(str) {
      return str.replace(EDGE_IS_STILL_SO_BAD, '');
    }
    const hasSupport = typeof Intl !== 'undefined';
    suite('Basics', () => {
      test('Renders date string value', (done) => {
        // Can't check date format at this point since it may vary depending
        // on the locale settings.
        const element = fixture('Basic');
        flush(() => {
          const txt = element.shadowRoot.innerHTML;
          assert.typeOf(txt, 'string');
          done();
        });
      });

      test('Should compute ISO time', (done) => {
        const element = fixture('Basic');
        flush(() => {
          assert.equal(element.getAttribute('datetime'), '2010-12-10T11:05:45.000Z');
          done();
        });
      });

      test('Should set weekday', (done) => {
        if (hasSupport) {
          const element = fixture('LongWeekday');
          flush(() => {
            const txt = element.shadowRoot.innerHTML;
            assert.equal(normalizeString(txt), 'Friday');
            done();
          });
        } else {
          done();
        }
      });

      test('Sets year', () => {
        if (hasSupport) {
          const element = fixture('NumericYear');
          const txt = element.shadowRoot.innerHTML;
          assert.equal(normalizeString(txt), '2010');
        }
      });

      test('Should set month', () => {
        if (hasSupport) {
          const element = fixture('LongMonth');
          const txt = element.shadowRoot.innerHTML;
          assert.equal(normalizeString(txt), 'December');
        }
      });

      test('Should set day', () => {
        if (hasSupport) {
          const element = fixture('NumericDay');
          const txt = element.shadowRoot.innerHTML;
          assert.equal(normalizeString(txt), '10');
        }
      });

      test('Should set hour', () => {
        if (hasSupport) {
          const element = fixture('NumericHour');
          const txt = element.shadowRoot.innerHTML;
          assert.equal(normalizeString(txt), '11 AM');
        }
      });
    });

    suite('Attributes settings', () => {
      let element;
      setup(() => {
        element = fixture('Empty');
      });

      [
        ['locales'], ['date'], ['year'], ['month'], ['day'], ['hour'], ['minute'], ['second'],
        ['weekday', undefined, 'short'], ['time-zone-name', 'timeZoneName', 'short'],
        ['era', undefined, 'narrow'], ['time-zone', 'timeZone', 'UTC'], ['hour12', undefined, true]
      ].forEach((item) => {
        test(`Calls _updateLabel() when "${item[0]}" attribute changes`, () => {
          const value = item[2] || 'numeric';
          const spy = sinon.spy(element, '_updateLabel');
          element.setAttribute(item[0], value);
          assert.isTrue(spy.called);
        });

        test(`Updates propety value when "${item[0]}" attribute changes`, () => {
          const prop = item[1] || item[0];
          const value = item[2] || 'numeric';
          element.setAttribute(item[0], value);
          if (prop === 'hour12') {
            assert.isTrue(element[prop]);
          } else {
            assert.equal(element[prop], value);
          }
        });
      });
    });

    suite('Properies changed', () => {
      let element;
      setup(() => {
        element = fixture('Empty');
      });

      [
        ['locales'], ['date'], ['year'], ['month'], ['day'], ['hour'], ['minute'], ['second'],
        ['weekday', undefined, 'short'], ['time-zone-name', 'timeZoneName', 'short'],
        ['era', undefined, 'narrow'], ['time-zone', 'timeZone', 'UTC'], ['hour12', undefined, true]
      ].forEach((item) => {
        test(`Calls _updateLabel() when "${item[0]}" property change`, () => {
          const value = item[2] || 'numeric';
          const prop = item[1] || item[0];
          const spy = sinon.spy(element, '_updateLabel');
          element[prop] = value;
          assert.isTrue(spy.called);
        });

        test(`Updates attribute value when "${item[0]}" property changes`, () => {
          const attr = item[0];
          const prop = item[1] || attr;
          const value = item[2] || 'numeric';
          element[prop] = value;
          assert.isTrue(element.hasAttribute(attr), 'Has corresponding attribute');
          if (prop !== 'hour12') {
            assert.equal(element.getAttribute(attr), value);
          }
        });
      });
    });

    suite('_getIntlOptions()', () => {
      let element;
      setup(() => {
        element = fixture('Empty');
      });

      [
        ['year'], ['month'], ['day'], ['hour'], ['minute'], ['second'],
        ['weekday', undefined, 'short'], ['time-zone-name', 'timeZoneName', 'short'],
        ['era', undefined, 'narrow'], ['time-zone', 'timeZone', 'UTC'], ['hour12', undefined, true]
      ].forEach((item) => {
        test(`Adds "${item[0]}" property`, () => {
          const attr = item[0];
          const prop = item[1] || attr;
          const value = item[2] || 'numeric';
          element[prop] = value;
          const result = element._getIntlOptions();
          if (prop === 'hour12') {
            assert.isTrue(result[prop]);
          } else {
            assert.equal(result[prop], value);
          }
        });
      });
    });

    // a11ySuite('Basic');
    </script>

  </body>
</html>
